PS- KOKO EATING BANANAS

/* CODE */
class Solution {
    public int minEatingSpeed(int[] arr, int h) {
        int l=1;
        int r = 1000000001;
        int ans=0;
        while(l<=r){
            int mid = l+ (r-l)/2;
            if(binarySearch(arr, mid, h)){
                ans=mid;
                r=mid-1;    //let's look for even a better solution on left
            }
            else l=mid+1;
        }
        return ans;
    }

    public boolean binarySearch(int arr[], int mid, int h){
        int hoursNeeded=0;
        for(int i=0;i<arr.length;i++){
            hoursNeeded += (arr[i] + mid-1)/mid; // calculate ceiling of arr[i]/mid
            //hoursNeeded += Math.ceil((double)arr[i]/mid);    //arr[i] and mid are integers so division still return a back int, so make one of them double to get fractions
            if(hoursNeeded>h) return false; //police came even before finishing banana
        }
        return hoursNeeded<=h;
    }
}


/*
LOGIC---
Now we need to decide on a number which is the eating speed of koko, x banana/hour.
For the given number of hours we want the array elemtns (all banana in each pile) to become 0.

Much easier to understand, if say each index is a box and contains arr[i] bananas in it. We have h hours. In 1 hr the monkey will only go for one box and no more. We need to find min x speed to finish all the bananas.

Now the range of eating banana speed can vary from 1 to the largest element in the array.

So, in search space range (1, max(arr)) => our solution exist
=> the range space is sorted
form => NNNNNNNNNNNYYYYYYYYYY => need to find the first Y

BINARY SEARCH ON ANSWER

Note - don't do the foolish mistake of updating original array and h in function, which you always did
Use ciel values
*/




/*************************************************************************************************/
PS- 719. Find K-th Smallest Pair Distance
The distance of a pair of integers a and b is defined as the absolute difference between a and b.
Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.

Input: nums = [1,3,1], k = 1
Output: 0
Explanation: Here are all the pairs: (1,3) -> 2, (1,1) -> 0, (3,1) -> 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.


/* CODE */
/* Binary Search + Two-Pointer Technique */
class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        int l=0;
        int r=nums[nums.length-1] - nums[0];    //max possible difference
        int ans=0;
        while(l<=r){
            int mid=l+(r-l)/2;
            int countpairs = slidingwindow(nums, mid);
            if(countpairs<k) l=mid+1;  //we need more distance values so look ahead
            else{
                ans=mid;
                r=mid-1;
            }
        }
        return ans;
    }

    public int slidingwindow(int nums[], int mid){
        int i=0;
        int j=1;
        int pair=0;
        while(i<nums.length && j<nums.length){
            while(nums[j]-nums[i]>mid) i++; //we want pairs that have distance greater than mid, if not possible check pairs from next index
            pair+=j-i;
            j++;    //keeping i constant, check for next indexes to form pair with i
        }
        return pair;

    }
}

/*
LOGIC---
Binary Search on answer
Use binary search on possible pair distances (from 0 to the maximum difference in the sorted array). For each midpoint in the binary search, count pairs with distances ≤ this midpoint. Adjust the search range based on whether the count is less than or greater than k. This method efficiently narrows down to the k-th smallest distance by leveraging sorting and binary search.

So, from 0 till the max possible difference is a range space.

Each distance could have possible multiple pairs having same distance.

eg: [1,4,5,10] => sorted arr

Now when having i=1, j=10 and we say we need distance of pairs to be less than 50.
So, if 10-1=9<50 => it menas that other number between 1 and 10 would form a pair with 10 and still have distance less than 50.
Hnece j-i = no of pairs have distance less than x

So, what we are seeking is for the distance to have x value => x pairs basically the distance index should have k in its value only then it will be ou answer

=> its kind of like saying, there are k pairs having distance less than equal to x (0->x)


APPROACH---
    Binary Search:
        Calculate mid as the average of left and right.
        Use the issmallpairs() function to determine if there are at least k pairs with a distance less than or equal to mid.
        If issmallpairs() returns true, move right to mid to search for potentially smaller distances.
        f issmallpairs() returns false, move left to mid + 1 to search for larger distances.
        When the loop terminates, left will hold the k-th smallest distance.

    issmallpairs() function:
        This function counts how many pairs have a distance less than or equal to mid.
        Use a two-pointer technique where right iterates over the array and left advances when the distance exceeds mid.

TC - O(nlogn + nlog(max distance))
*/


/* BRUTE FORCE MAXHEAP TLE O(n^2 logk) */
class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        PriorityQueue<Integer> maxheap = new PriorityQueue<>(Collections.reverseOrder());
        ArrayList<Integer> dif= new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                maxheap.add(Math.abs(nums[j]-nums[i]));
                if(maxheap.size()>k) maxheap.poll();
            }
        }
        return maxheap.peek();
    }
}

/*
LOGIC---
use a Max-Heap (PriorityQueue in Java) to keep track of the smallest k distances.
we need smallest k dist => MAX-HEAP

Steps:
    - Iterate over all possible pairs (i, j) where i < j in      the array.
    - For each pair, calculate the absolute difference abs(nums[i] - nums[j]).
    - Add the difference to a Max-Heap.
    - If the size of the Max-Heap exceeds k, remove the largest element (this ensures that the heap only contains the k smallest differences).
    - Finally, return the top element of the Max-Heap, which is the k-th smallest distance.

Why TLE?
    - The approach is O(n^2 log k) where n is the length of the array.
    - The double loop over the pairs (i, j) makes it O(n^2).
    - Since you’re using a heap, each insertion and deletion operation is O(log k)
*/

/* BRUTE FORCE FREQUENCY COUNT TABLE O(n^2), O(m) */
Make a frequency table ranging from 0 to max_el(arr)-min_el(arr)
Find all pairs diff and put inside the above frequency table.
FInally find the kth term through freq table.


/* BRUTE FORCE O(N^2) */
Find all pair distances.
Put them in a list of ditances => sort them
return the kth element.

From here, you can have a thinking that what if we already had the list of distances in a sorted fashion. => like a count table showing no of pairs for each distance.
Would make life easy for us. => BINARY SEARCH ON ANSWER ON THIS VERY LIST => Something like applying binary search on answer



/*************************************************************************************************/

PS- Maximum Value (GFG contest 168)
The score of the array is defined as the minimum element in the array. Your goal is to maximize the score of the array.
You are allowed to perform the following operation any number of times:
• Choose any element from arr[i]. => Subtract k from arr[i] => Add 1 to any element in the array

Return the maximum score of the array you can achieve. In one operation you have to perform all three steps.
Input: n = 3, k = 2, arr = [1,0,3]
Output: 1
Explanation: Performing the operation once, removing 2 from third index and adding 1 to the second index, the array becomes [1,1,1]. 
The minimum value of the array is 1. We can see this is the maximum score of the array.

/* BINARY SEARCH ON ANSWER */
class Solution {
    public static int maxValueArray(int n, int k, int[] arr) {
        long l = 0;
        long r = 1000000000;    //see contriants of array values
        long ans = -1;  
        while (l <= r) {
            long mid = (l+r)/2;
            if (binary(arr, k, mid)) {
                ans = mid;  
                l = mid + 1;
            } 
            else r = mid - 1;
        }
        return (int)ans;
    }

    public static boolean binary(int[] arr, int k, long mid) {
        long powerofadding1 = 0;
        long  requiredpowerof1 = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > mid) powerofadding1 += (arr[i] - mid) / k;
            else  requiredpowerof1 += (mid - arr[i]);
        }
        if(powerofadding1 - requiredpowerof1 >= 0) return true;
        else return false;
    }
}

/*
LOGIC---
Maximise the minimum score(~element) of array => possiblity of binary search
Applying operations will be easier if we have sorted array => binary search confirmed

Our ans will only exist from the minimum to maximum elemnt of array.

We will get : YYYYYYYNNNNNNN
So, we need last Y.

So, if mid is our possible final maximised minimum value of array.
Subtracting k from an element gives us the power of adding 1 to any element.
But since mid is our minimum element in array. We wouldn't want the element from whwich we are subtracting k go lower than mid.

So, powerofadding1 = (arr[i]-mid)/k;

Now we ened to check whether powerofadding1 is enough to bring all element to mid, in case some are still les than mid.
So, requiredpowerof1 = mid-arr[i];

Now if requiredpowerof1-powerofadding1>=0 => we say its possible to get mid as the minimum of our array.
TC - O(nlogn) => inside binary search iterating array each time
*/



/*************************************************************************************************/



